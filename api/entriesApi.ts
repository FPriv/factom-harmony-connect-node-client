/**
 * Harmony Connect
 * An easy to use API that helps you access the Factom blockchain.
 *
 * OpenAPI spec version: 1.0.17
 * Contact: harmony-support@factom.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { Entry } from '../model/entry';
import { EntryCreate } from '../model/entryCreate';
import { EntryList } from '../model/entryList';
import { EntrySearchResponse } from '../model/entrySearchResponse';
import { EntryShort } from '../model/entryShort';
import { SearchBody } from '../model/searchBody';

import { ObjectSerializer, Authentication, HttpBasicAuth, ApiKeyAuth, OAuth, VoidAuth } from '../model/models';

let defaultBasePath = 'https://connect-shared-sandbox-2445582615332.production.gw.apicast.io/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum EntriesApiApiKeys {
    AppId,
    AppKey,
}

export class EntriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AppId': new ApiKeyAuth('header', 'app_id'),
        'AppKey': new ApiKeyAuth('header', 'app_key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: EntriesApiApiKeys, value: string) {
        (this.authentications as any)[EntriesApiApiKeys[key]].apiKey = value;
    }

    /**
     * List all entries contained on the specified chain.
     * @summary Get Chain's Entries
     * @param chainId Chain identifier
     * @param limit The number of items you would like back in each page.
     * @param offset The page you would like to request. The first page offset is Zero.
     * @param stages The immutability stages you want to restrict results to. You can choose any from &#x60;replicated&#x60;, &#x60;factom&#x60;, and &#x60;anchored&#x60;. If you would like to search among multiple stages, send them in a comma separated string. For example: &#x60;&#39;multi_az,factom&#39;&#x60;.
     */
    public getEntriesByChainID (chainId: string, limit?: number, offset?: number, stages?: string) : Promise<{ response: http.IncomingMessage; body: EntryList;  }> {
        const localVarPath = this.basePath + '/chains/{chain_id}/entries'
            .replace('{' + 'chain_id' + '}', encodeURIComponent(String(chainId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'chainId' is not null or undefined
        if (chainId === null || chainId === undefined) {
            throw new Error('Required parameter chainId was null or undefined when calling getEntriesByChainID.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (stages !== undefined) {
            localVarQueryParameters['stages'] = ObjectSerializer.serialize(stages, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AppId.applyToRequest(localVarRequestOptions);

        this.authentications.AppKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EntryList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EntryList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns information about a specific entry on Connect. The requested entry must be specified using the Chain ID and Entry Hash.
     * @summary Get Entry Info
     * @param chainId Chain identifier
     * @param entryHash The SHA256 hash of the entry.
     */
    public getEntryByHash (chainId: string, entryHash: string) : Promise<{ response: http.IncomingMessage; body: Entry;  }> {
        const localVarPath = this.basePath + '/chains/{chain_id}/entries/{entry_hash}'
            .replace('{' + 'chain_id' + '}', encodeURIComponent(String(chainId)))
            .replace('{' + 'entry_hash' + '}', encodeURIComponent(String(entryHash)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'chainId' is not null or undefined
        if (chainId === null || chainId === undefined) {
            throw new Error('Required parameter chainId was null or undefined when calling getEntryByHash.');
        }

        // verify required parameter 'entryHash' is not null or undefined
        if (entryHash === null || entryHash === undefined) {
            throw new Error('Required parameter entryHash was null or undefined when calling getEntryByHash.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AppId.applyToRequest(localVarRequestOptions);

        this.authentications.AppKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Entry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Entry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the first entry that has been saved to this chain.
     * @summary Get Chain's First Entry
     * @param chainId Chain identifier
     */
    public getFirstEntry (chainId: string) : Promise<{ response: http.IncomingMessage; body: Entry;  }> {
        const localVarPath = this.basePath + '/chains/{chain_id}/entries/first'
            .replace('{' + 'chain_id' + '}', encodeURIComponent(String(chainId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'chainId' is not null or undefined
        if (chainId === null || chainId === undefined) {
            throw new Error('Required parameter chainId was null or undefined when calling getFirstEntry.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AppId.applyToRequest(localVarRequestOptions);

        this.authentications.AppKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Entry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Entry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the last entry that has been saved to this chain.
     * @summary Get Chain's Last Entry
     * @param chainId Chain identifier
     */
    public getLastEntry (chainId: string) : Promise<{ response: http.IncomingMessage; body: Entry;  }> {
        const localVarPath = this.basePath + '/chains/{chain_id}/entries/last'
            .replace('{' + 'chain_id' + '}', encodeURIComponent(String(chainId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'chainId' is not null or undefined
        if (chainId === null || chainId === undefined) {
            throw new Error('Required parameter chainId was null or undefined when calling getLastEntry.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AppId.applyToRequest(localVarRequestOptions);

        this.authentications.AppKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Entry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Entry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Find all of the entries within the specified chain that have the requested `external_ids`.
     * @summary Search Chain's Entries
     * @param chainId Chain identifier
     * @param searchBody 
     * @param limit The number of items you would like back in each page.
     * @param offset The page you would like to request. The first page offset is Zero.
     */
    public postEntriesSearch (chainId: string, searchBody: SearchBody, limit?: number, offset?: number) : Promise<{ response: http.IncomingMessage; body: EntrySearchResponse;  }> {
        const localVarPath = this.basePath + '/chains/{chain_id}/entries/search'
            .replace('{' + 'chain_id' + '}', encodeURIComponent(String(chainId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'chainId' is not null or undefined
        if (chainId === null || chainId === undefined) {
            throw new Error('Required parameter chainId was null or undefined when calling postEntriesSearch.');
        }

        // verify required parameter 'searchBody' is not null or undefined
        if (searchBody === null || searchBody === undefined) {
            throw new Error('Required parameter searchBody was null or undefined when calling postEntriesSearch.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(searchBody, "SearchBody")
        };

        this.authentications.AppId.applyToRequest(localVarRequestOptions);

        this.authentications.AppKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EntrySearchResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EntrySearchResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new entry for the selected chain. Content and external id must be uploaded in Base64 format.
     * @summary Create an Entry
     * @param chainId Chain identifier
     * @param entryCreate 
     */
    public postEntryToChainID (chainId: string, entryCreate: EntryCreate) : Promise<{ response: http.IncomingMessage; body: EntryShort;  }> {
        const localVarPath = this.basePath + '/chains/{chain_id}/entries'
            .replace('{' + 'chain_id' + '}', encodeURIComponent(String(chainId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'chainId' is not null or undefined
        if (chainId === null || chainId === undefined) {
            throw new Error('Required parameter chainId was null or undefined when calling postEntryToChainID.');
        }

        // verify required parameter 'entryCreate' is not null or undefined
        if (entryCreate === null || entryCreate === undefined) {
            throw new Error('Required parameter entryCreate was null or undefined when calling postEntryToChainID.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(entryCreate, "EntryCreate")
        };

        this.authentications.AppId.applyToRequest(localVarRequestOptions);

        this.authentications.AppKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EntryShort;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EntryShort");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
